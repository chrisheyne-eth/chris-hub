<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chris' Tetris</title>
  <style>
    body {
      background: white;
      color: black;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      height: 100vh;
      margin: 0;
      font-family: monospace, monospace;
      user-select: none;
    }

    #game {
      margin-top: 20px;
    }

    canvas {
      background: white;
      border: 2px solid black;
      display: block;
      margin-bottom: 10px;
    }

    #score {
      font-size: 18px;
      text-align: center;
    }

    #controls {
      font-size: 14px;
      margin-top: 8px;
      text-align: center;
      line-height: 1.4;
    }
  </style>
</head>

<body>
  <div id="game">
    <canvas id="board" width="240" height="400"></canvas>
    <div id="score">Score: 0</div>
    <div id="controls">
      Controls: ← → (Move) | ↑ (Rotate) | ↓ (Soft Drop) | Space (Hard Drop)
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('board');
      const ctx = canvas.getContext('2d');
      const scale = 20;
      const cols = 12;
      const rows = 20;

      // The Tetris board matrix (0 = empty)
      let board = [];
      for (let r = 0; r < rows; r++) {
        board[r] = new Array(cols).fill(0);
      }

      // Tetromino shapes in 4 rotations
      const tetrominos = {
        I: [
          [[0, 0, 0, 0],
          [1, 1, 1, 1],
          [0, 0, 0, 0],
          [0, 0, 0, 0]],
          [[0, 0, 1, 0],
          [0, 0, 1, 0],
          [0, 0, 1, 0],
          [0, 0, 1, 0]],
        ],
        J: [
          [[1, 0, 0],
          [1, 1, 1],
          [0, 0, 0]],
          [[0, 1, 1],
          [0, 1, 0],
          [0, 1, 0]],
          [[0, 0, 0],
          [1, 1, 1],
          [0, 0, 1]],
          [[0, 1, 0],
          [0, 1, 0],
          [1, 1, 0]],
        ],
        L: [
          [[0, 0, 1],
          [1, 1, 1],
          [0, 0, 0]],
          [[0, 1, 0],
          [0, 1, 0],
          [0, 1, 1]],
          [[0, 0, 0],
          [1, 1, 1],
          [1, 0, 0]],
          [[1, 1, 0],
          [0, 1, 0],
          [0, 1, 0]],
        ],
        O: [
          [[1, 1],
          [1, 1]],
        ],
        S: [
          [[0, 1, 1],
          [1, 1, 0],
          [0, 0, 0]],
          [[0, 1, 0],
          [0, 1, 1],
          [0, 0, 1]],
        ],
        T: [
          [[0, 1, 0],
          [1, 1, 1],
          [0, 0, 0]],
          [[0, 1, 0],
          [0, 1, 1],
          [0, 1, 0]],
          [[0, 0, 0],
          [1, 1, 1],
          [0, 1, 0]],
          [[0, 1, 0],
          [1, 1, 0],
          [0, 1, 0]],
        ],
        Z: [
          [[1, 1, 0],
          [0, 1, 1],
          [0, 0, 0]],
          [[0, 0, 1],
          [0, 1, 1],
          [0, 1, 0]],
        ],
      };

      // Tetromino types array for random pick
      const types = Object.keys(tetrominos);

      // Current piece info
      let current = {
        x: 0,
        y: 0,
        shape: null,
        rotation: 0,
        matrix: null,
      };

      // Score
      let score = 0;

      function createPiece() {
        const type = types[Math.floor(Math.random() * types.length)];
        const rotations = tetrominos[type];
        const rotation = 0;
        return {
          x: Math.floor(cols / 2) - Math.ceil(rotations[rotation][0].length / 2),
          y: 0,
          shape: type,
          rotation,
          matrix: rotations[rotation],
        };
      }

      function rotate(piece) {
        const rotations = tetrominos[piece.shape];
        piece.rotation = (piece.rotation + 1) % rotations.length;
        piece.matrix = rotations[piece.rotation];
        // If rotation causes collision or out of bounds, revert
        if (collides(piece)) {
          // Try wall kicks: left or right shift
          if (!tryMove(piece, -1)) {
            if (!tryMove(piece, 1)) {
              // Revert rotation if no way to fix collision
              piece.rotation = (piece.rotation - 1 + rotations.length) % rotations.length;
              piece.matrix = rotations[piece.rotation];
              return false;
            }
          }
        }
        return true;
      }

      function tryMove(piece, offsetX) {
        piece.x += offsetX;
        if (collides(piece)) {
          piece.x -= offsetX;
          return false;
        }
        return true;
      }

      function collides(piece) {
        for (let r = 0; r < piece.matrix.length; r++) {
          for (let c = 0; c < piece.matrix[r].length; c++) {
            if (piece.matrix[r][c]) {
              const x = piece.x + c;
              const y = piece.y + r;
              if (x < 0 || x >= cols || y >= rows || (y >= 0 && board[y][x])) {
                return true;
              }
            }
          }
        }
        return false;
      }

      function freeze() {
        for (let r = 0; r < current.matrix.length; r++) {
          for (let c = 0; c < current.matrix[r].length; c++) {
            if (current.matrix[r][c]) {
              const x = current.x + c;
              const y = current.y + r;
              if (y >= 0) {
                board[y][x] = 1;
              }
            }
          }
        }
      }

      function clearLines() {
        let linesCleared = 0;
        for (let r = rows - 1; r >= 0; r--) {
          if (board[r].every(cell => cell === 1)) {
            board.splice(r, 1);
            board.unshift(new Array(cols).fill(0));
            linesCleared++;
            r++; // recheck this row after splice
          }
        }
        if (linesCleared > 0) {
          score += linesCleared * linesCleared * 100;
          document.getElementById('score').textContent = 'Score: ' + score;
        }
      }

      function drop() {
        current.y++;
        if (collides(current)) {
          current.y--;
          freeze();
          clearLines();
          current = createPiece();
          if (collides(current)) {
            // Game over
            alert('Game Over! Your score: ' + score);
            reset();
          }
        }
      }

      function hardDrop() {
        while (!collides(current)) {
          current.y++;
        }
        current.y--;
        freeze();
        clearLines();
        current = createPiece();
        if (collides(current)) {
          alert('Game Over! Your score: ' + score);
          reset();
        }
      }

      function reset() {
        board = [];
        for (let r = 0; r < rows; r++) {
          board[r] = new Array(cols).fill(0);
        }
        score = 0;
        document.getElementById('score').textContent = 'Score: 0';
        current = createPiece();
      }

      function drawCell(x, y, fill = true) {
        ctx.fillStyle = fill ? 'black' : 'white';
        ctx.fillRect(x * scale, y * scale, scale, scale);
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.strokeRect(x * scale, y * scale, scale, scale);
      }

      function drawBoard() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            if (board[r][c]) {
              drawCell(c, r);
            } else {
              // Draw white cells with black border for grid effect
              drawCell(c, r, false);
            }
          }
        }
        // Draw current piece
        for (let r = 0; r < current.matrix.length; r++) {
          for (let c = 0; c < current.matrix[r].length; c++) {
            if (current.matrix[r][c]) {
              const x = current.x + c;
              const y = current.y + r;
              if (y >= 0) drawCell(x, y);
            }
          }
        }
      }

      // Controls
      document.addEventListener('keydown', e => {
        switch (e.key) {
          case 'ArrowLeft':
            if (!collides({ ...current, x: current.x - 1 })) current.x--;
            break;
          case 'ArrowRight':
            if (!collides({ ...current, x: current.x + 1 })) current.x++;
            break;
          case 'ArrowDown':
            drop();
            break;
          case 'ArrowUp':
            rotate(current);
            break;
          case ' ':
            e.preventDefault();
            hardDrop();
            break;
        }
        drawBoard();
      });

      // Game loop (drop piece every 500ms)
      let dropInterval = 500;
      let lastTime = 0;

      function update(time = 0) {
        if (!lastTime) lastTime = time;
        const delta = time - lastTime;
        if (delta > dropInterval) {
          drop();
          drawBoard();
          lastTime = time;
        }
        requestAnimationFrame(update);
      }

      current = createPiece();
      drawBoard();
      update();
    })();
  </script>
</body>

</html>